#include "Rcpp.h"
#include "shared_utils.h"
using namespace Rcpp;

// Required to print cout output generated by ompBAM
#define cout Rcpp::Rcout

// [[Rcpp::depends(ompBAM)]]
#include <ompBAM.hpp>

// Calculate the length of alignment from the CIGAR
int32_t cigarLength(const uint32_t* cigar, int n_cigar_op) {
  int32_t length = 0;
  for (int i = 0; i < n_cigar_op; ++i) {
    uint32_t op_and_len = cigar[i];
    uint32_t op = op_and_len & 0xF; // Last 4 bits: operation
    uint32_t len = op_and_len >> 4; // Rest: length
    if (op == 0 || op == 2 || op == 3) { // M, D, or N operations
      length += len;
    }
  }
  return length;
}

// [[Rcpp::export]]
DataFrame extract_alignment_details_paired(std::string bam_file, int n_threads_to_use = 1) {
  // Ensure number of threads requested < number of system threads available
  unsigned int n_threads_to_really_use = use_threads(n_threads_to_use);

  pbam_in inbam;
  inbam.openFile(bam_file, n_threads_to_really_use);

  std::vector<std::string> seqnames; 
  std::vector<int32_t> starts;
  std::vector<int32_t> ends;
  std::vector<std::string> cigars;
  std::vector<std::string> sequences;
  std::vector<std::string> strands;
  std::vector<std::string> quality_scores;
  std::vector<std::string> read_ids; 
  std::vector<int32_t> template_length; 
  
  std::vector<int> mapping_quality;
  std::vector<int> mate_mapq;

  std::vector<std::string> mate_seqnames;
  std::vector<int32_t> mate_positions;

  std::vector<std::string> s_chr_names;
  std::vector<uint32_t> u32_chr_lens;
  int chrom_count = inbam.obtainChrs(s_chr_names, u32_chr_lens);

  // If obtainChrs returns zero or negative # chromosomes, BAM reading has failed
  if (chrom_count <= 0) {
    inbam.closeFile();
    return DataFrame::create();
  }

  while (0 == inbam.fillReads()) {
    #ifdef _OPENMP
    #pragma omp parallel for num_threads(n_threads_to_really_use) schedule(static,1)
    #endif
    for (unsigned int i = 0; i < n_threads_to_really_use; i++) {
      pbam1_t read(inbam.supplyRead(i));

      while (read.validate()) {
        if (read.flag() & 0x1) { // Ensure it's paired
          // Placeholders for mate information
          std::string mate_seqname_placeholder = "NA";
          int32_t mate_position_placeholder = -1;

          // Get the readID 
          std::string read_id = (read.flag() & 0x40) ? "R1" : ((read.flag() & 0x80 ? "R2" : "NA"));

          // Extract primary alignment details
          #pragma omp critical
          {
            // Extract sequence name
            seqnames.push_back(s_chr_names.at(read.refID()));
            
            // Start and end positions 
            int32_t start = read.pos() + 1;
            starts.push_back(start);

            // Process CIGAR for length
            const uint32_t* cigar = read.cigar();
            int n_cigar_op = read.n_cigar_op();

            std::string cigar_str;
            read.cigar(cigar_str);
            cigars.push_back(cigar_str);
            ends.push_back(start + cigarLength(cigar, n_cigar_op) - 1);

            // Extract sequence
            std::string seq;
            read.seq(seq);
            sequences.push_back(seq);

            // Extract mapq for primary read 
            mapping_quality.push_back(static_cast<int>(read.mapq()));

            // Strand information
            strands.push_back((read.flag() & 0x10) ? "-" : "+");

            // Template Length Information 
            template_length.push_back(read.tlen());

            // Extract quality scores
            std::vector<uint8_t> qual_scores; 
            read.qual(qual_scores);
            if (!qual_scores.empty()) { 
              for (auto &q : qual_scores) {
                q += 33; // ASCII format
              }
              quality_scores.push_back(std::string(qual_scores.begin(), qual_scores.end()));
            } else {
              quality_scores.push_back("NA");
            }

            // Mate information using `next_refID()` and `next_pos()`
            if (read.next_refID() >= 0) {
              mate_seqname_placeholder = s_chr_names.at(read.next_refID());
              mate_position_placeholder = read.next_pos() + 1;
              mate_mapq.push_back(static_cast<int>(read.mapq()));
            } else {
              mate_seqnames.push_back("NA");
              mate_positions.push_back(-1);
            }

            mate_seqnames.push_back(mate_seqname_placeholder);
            mate_positions.push_back(mate_position_placeholder);

            // Add the readID 
            read_ids.push_back(read_id);
          }
        }

        // Get next read
        read = inbam.supplyRead(i);
      }
    }
  }

  inbam.closeFile();
  
  // Debug print lengths for consistency
  cout << "Lengths: " 
       << "seqnames=" << seqnames.size() 
       << ", starts=" << starts.size() 
       << ", ends=" << ends.size() 
       << ", cigars=" << cigars.size() 
       << ", sequences=" << sequences.size() 
       << ", strands=" << strands.size() 
       << ", quality_scores=" << quality_scores.size()
       << ", mate_seqnames=" << mate_seqnames.size() 
       << ", mate_positions=" << mate_positions.size() 
       << ", read_ids=" << read_ids.size() 
       << std::endl;


  return DataFrame::create(
    Named("seqnames") = seqnames,
    Named("start") = starts,
    Named("end") = ends, 
    Named("cigar") = cigars,
    Named("sequences") = sequences,
    Named("mapq") = mapping_quality,
    Named("mate_mapq") = mate_mapq,
    Named("strand") = strands,
    Named("quality_scores") = quality_scores,
    Named("mate_seqnames") = mate_seqnames,
    Named("mate_positions") = mate_positions,
    Named("read_id") = read_ids,
    Named("template_length") = template_length
  );
}

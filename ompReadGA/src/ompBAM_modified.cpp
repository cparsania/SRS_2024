#include "Rcpp.h"
#include "shared_utils.h"
using namespace Rcpp;

// Required to print cout output generated by ompBAM
#define cout Rcpp::Rcout

// [[Rcpp::depends(ompBAM)]]
#include <ompBAM.hpp>


int32_t cigarLength(const std::string &cigar) {
  int32_t length = 0; 
  std::string num = "";
  for (char c : cigar) {
    if (isdigit(c)) {
      num += c; 
    } else { 
      if (c == 'M' || c == 'D' || c == 'N') {
        length += std::stoi(num);
      }
      num = "";
    }
  }
  return length;
}


// [[Rcpp::export]]
DataFrame extract_alignment_details(std::string bam_file, int n_threads_to_use = 1){

  // Ensure number of threads requested < number of system threads available
  unsigned int n_threads_to_really_use = use_threads(n_threads_to_use);

  pbam_in inbam;
  inbam.openFile(bam_file, n_threads_to_really_use);
  
  std::vector<std::string> s_chr_names;
  std::vector<std::string> seqnames; 
  std::vector<uint32_t> u32_chr_lens;
  std::vector<int32_t> starts;
  std::vector<int32_t> ends;
  std::vector<std::string> cigars;
  std::vector<std::string> sequences;
  std::vector<std::string> strands;
  std::vector<std::string> quality_scores; 
  std::vector<int> mapping_quality; 

  int chrom_count = inbam.obtainChrs(s_chr_names, u32_chr_lens);

  // If obtainChrs returns zero or negative # chromosomes, BAM reading has failed
  if(chrom_count <= 0) {
    inbam.closeFile();
    return DataFrame::create();
  }
    

  
  // Creates a data structure that stores per-chromosome read counts
  std::vector<uint32_t> total_reads(chrom_count);

  while(0 == inbam.fillReads()) {
    // OpenMP parallel FOR loop, each thread runs 1 loop simultaneously.
    #ifdef _OPENMP
    #pragma omp parallel for num_threads(n_threads_to_really_use) schedule(static,1)
    #endif
    for(unsigned int i = 0; i < n_threads_to_really_use; i++) {
      std::vector<uint32_t> read_counter(chrom_count);
      
      // Gets the first read from the thread read storage buffer
      pbam1_t read(inbam.supplyRead(i));
      // Keep looping while reads are valid
      while(read.validate()) {
        // Counts the read if it is mapped to a chromosome
        if(read.refID() >= 0 && read.refID() < chrom_count) {
          read_counter.at(read.refID())++;
          #pragma omp critical 
          {
            // Extract details for Genomic Alignments 
            seqnames.push_back(s_chr_names.at(read.refID()));
            int32_t start = read.pos() + 1;
            starts.push_back(start);

            // Calculate end position from CIGAR 
            std::string cigar_str;
            read.cigar(cigar_str);
            int32_t end = start + cigarLength(cigar_str) - 1;
            ends.push_back(end);

            cigars.push_back(cigar_str);
            strands.push_back((read.flag() & 0x10) ? "-" : "+");
            std::string seq;
            read.seq(seq);
            sequences.push_back(seq);

            // Mapping quality 
            mapping_quality.push_back(static_cast<int>(read.mapq()));

            // Extract quality scores
            std::vector<uint8_t> qual_vec;
            read.qual(qual_vec);
            
            if (!qual_vec.empty() && qual_vec.at(0) != 255) {
              // Convert to ASCII (Phred+33) if valid
              for (uint8_t &q : qual_vec) {
                q += 33;
              }
              quality_scores.push_back(std::string(qual_vec.begin(), qual_vec.end()));
            } else {
              quality_scores.push_back("NA"); // Handle missing quality scores
            }


          }
        }
        
        // Gets the next read
        read = inbam.supplyRead(i);     
      }
      // Adds the counted reads to the final count
      // #pragma omp critical ensures only 1 thread at a time runs the following
      // block of code.
      #ifdef _OPENMP
      #pragma omp critical
      #endif
      for(unsigned int j = 0; j < (unsigned int)chrom_count; j++) {
        total_reads.at(j) += read_counter.at(j);
      }
    }
    // At this stage, all threads would have read all their thread-specific reads
    // At the next call to pbam_in::fillReads(), if any reads were not read, it
    // will throw an error and fillReads() will return -1.
    // If we have finished reading the BAM file, fillReads() will return 1.
  }

  inbam.closeFile();

  // Return extracted data as R Datafame 
  return DataFrame::create(
    Named("seqnames") = seqnames,
    Named("start") = starts,
    Named("end") = ends, 
    Named("cigar") = cigars,
    Named("strand") = strands,
    Named("sequences") = sequences,
    Named("quality_scores") = quality_scores,
    Named("mapq") = mapping_quality
  );
}
